#!/usr/bin/env zsh

# This should be private only.
# Without the calling function, this function will poison local state.

local -a parts=()
# match glob
glob=
for glob ("${(@)prompt_dir_glob__globs}"); do
	local f=("$head$dir/"$~glob)
	[[ -n $f ]] && break
	glob=fallback
done

# get prefix style
parts+=(${prompt_dir_glob__prefix[(e)$glob]:-"%F{$POWERLEVEL9K_DIR_FOREGROUND}"})

# {{{ truncate dir
# don't truncate show_init
local dir_truncated=''
if
	[[ -z $show_init && $prompt_dir_glob__truncate[(e)$glob] ]] &&
	{ [[ ${head:a}/$dir != $actual ]] || zstyle -t :dir-glob truncate-pwd false }
then
	case $prompt_dir_glob__truncate[(e)$glob] in
	u*) # unique
		for c (${(s::)dir}); do
			set +f
			dir_truncated+=$c
			local f=("$head$dir_truncated"*(Y2))
			(( $#f < 2 )) && break
		done
	;;
	c*) # char:NUM
		w=${${(M)prompt_dir_glob__truncate[(e)$glob]%%[[:digit:]]*}:-1}
		if (( w + 1 < $#dir )); then
			dir_truncated=${dir[1,w]}'\u2025'
		fi
	esac
fi
# }}}
parts+=(${show_init:-${dir_truncated:-$dir}})

# get suffix style
parts+=(${prompt_dir_glob__suffix[(e)$glob]})

# add to parts and cache
dir_parts+=(${__prompt_dir_glob__cache[$head$dir]::=${(j::)parts}})

# schedule cache writeout
if [[ ! ${(M)zsh_scheduled_events:#*prompt_dir-glob::flush-cache} ]]; then
	sched +15 prompt_dir-glob::flush-cache
fi
