#!/usr/bin/env zsh
# IMPORTANT: This should be private only.
# IMPORTANT: Without the calling function, this function will poison local state.

emulate -L zsh
setopt extendedglob nullglob

local -a parts=()
# {{{ check cache and match glob
local glob
if [[ -z ${glob::=$__prompt_dir_glob__cache[$head$dir]} ]]; then

	for glob ("${(@)prompt_dir_glob__globs}"); do
		local f=("$head$dir/"$~glob)
		[[ -n $f ]] && break
		# fallback value is an invalid glob (to prevent clobbering with user globs)
		glob='(#fallback)'
	done


	# write to cache array
	__prompt_dir_glob__cache[$head$dir]=$glob

	# schedule cache writeout
	if [[ ! ${(M)zsh_scheduled_events:#*prompt_dir_glob::flush_cache} ]]; then
		sched +15 prompt_dir_glob::flush_cache
	fi
fi
# }}}

# get prefix style
parts+=(${prompt_dir_glob__prefix[(e)$glob]:="%F{$POWERLEVEL9K_DIR_FOREGROUND}"})

# {{{ truncate dir
# don't truncate show_init
local dir_truncated=''
if
	[[ -z $show_init && $prompt_dir_glob__truncate[(e)$glob] ]] &&
	{ [[ ${head:a}/$dir != $actual ]] || zstyle -t :dir-glob truncate-pwd false }
then
	case $prompt_dir_glob__truncate[(e)$glob] in
	u*) # unique
		for c (${(s::)dir}); do
			set +f
			dir_truncated+=$c
			local f=("$head$dir_truncated"*(Y2))
			(( $#f < 2 )) && break
		done
	;;
	c*) # char:NUM
		w=${${(M)prompt_dir_glob__truncate[(e)$glob]%%[[:digit:]]*}:-1}
		if (( w == 0 )); then
			dir_truncated='%{%}' # print nothing
		elif (( w < $#dir )); then
			dir_truncated=${dir[0,w-1]}'\u2025'
		fi
	esac
fi
# }}}
parts+=(${show_init:-${dir_truncated:-$dir}})

# get suffix style
parts+=(${prompt_dir_glob__suffix[(e)$glob]})

# add to parts and cache
dir_parts+=("${(j::)parts}")
